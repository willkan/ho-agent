version: "3.0"
name: "Progressive Integration Development Workflow"
description: "Unified workflow focusing on solving integration hell through progressive integration"

# Core Philosophy
design_principles:
  - "Progressive integration - solve integration hell at its root"
  - "Natural language execution - Claude intelligently understands and executes"
  - "Intelligent problem handling - minimize human supervision"
  - "Layer-by-layer validation - catch issues early"

# Applicability
applicable_projects:
  - "Projects with 2+ modules requiring integration"
  - "Medium to large development projects"
  - "Any project where module interdependency exists"

non_applicable_projects:
  - "Single-file or single-module simple tools"
  - "Pure static pages"
  - "Simple scripts"

# Unified Workflow Execution Logic
workflow_execution: |
  Claude, this project has multiple modules and needs progressive integration to avoid integration hell:

  Stage 1 - Complete Planning and Design:
  Execute concurrently:
  - Task(requirements-analyst, "Analyze user requirements thoroughly, output requirements document")
  - Task(technical-architect, "Design system architecture with focus on module separation and interface design")
  - Task(ux-designer, "Design user interface and interaction flows")
  
  After planning completion:
  - Task(project-manager, "Based on architecture design, generate module configuration file including:
    * All modules list with priorities and dependencies
    * Layered development plan based on dependency relationships  
    * Detailed interface definitions and data models")
  
  Stage 2 - Progressive Development (CORE! Solves integration hell):
  
  Read module configuration file, execute by dependency layers:
  
  2.1) Develop Layer 1 modules (foundation modules with no dependencies):
       For each Layer 1 module, execute concurrently:
       - If backend_required: Task(backend-developer, "Develop ${module_name} backend, strictly follow interface definitions")
       - If frontend_required: Task(frontend-developer, "Develop ${module_name} frontend, use mock data for testing")
  
  2.2) Layer 1 Validation (CRITICAL STEP!):
       - Check if module files are completely generated
       - Verify API interfaces are implemented according to definitions
       - Run unit tests
       - Attempt to start services and test basic functionality
       
       âŒ If validation fails:
       - STOP immediately, do NOT proceed to Layer 2
       - Task(code-reviewer, "Analyze Layer 1 integration issues, provide specific fix solutions")
       - After fixes, re-validate Layer 1
       
       âœ… If validation passes: Continue to Layer 2 development
  
  2.3) Develop Layer 2 modules (dependent on Layer 1):
       - Develop based on validated Layer 1 interfaces
       - Task calls explicitly state: "Based on completed ${dependency_modules} interfaces, develop ${current_module}"
  
  2.4) Layer 2 Validation:
       - Run cross-module integration tests
       - Verify data flow between Layer 1 and Layer 2
       - Test complete business processes
  
  Continue this pattern - each layer MUST pass validation before proceeding to next layer.
  
  Stage 3 - Quality Assurance:
  - Task(qa-engineer, "Comprehensive testing of all features, focus on inter-module integration")
  - When issues found: Task(code-reviewer, "Analyze problems and provide fix recommendations")
  - Generate test reports and deployment documentation
  
  KEY PRINCIPLE: Validate each layer immediately after completion, catch and fix issues early, 
  avoid problem accumulation until final integration!

# Progressive Integration Core Mechanism
progressive_integration_solution:
  problem_root_cause: "Traditional development has modules developed independently, causing massive interface mismatch issues during final integration"
  
  solution_approach: |
    1. Dependency Analysis:
       - Automatically analyze inter-module dependency relationships
       - Organize modules into different layers based on dependencies
       - Layer 1: Foundation modules with no dependencies
       - Layer 2: Modules dependent only on Layer 1
       - Layer 3: Modules dependent on previous layers
    
    2. Layer-by-Layer Development:
       - Same-layer modules can be developed concurrently (no dependency conflicts)
       - Different layers must be developed sequentially
       - Subsequent layers must wait for previous layer validation
    
    3. Layer Validation:
       After each layer completion, immediately validate:
       - Are API interfaces implemented according to definitions?
       - Are data models consistent?
       - Are module calls functioning properly?
       - Do integration tests pass?
       
       Validation failure = immediate stop for fixes
       Validation success = proceed to next layer
    
    4. Early Problem Detection:
       - Interface mismatches discovered during development phase
       - Data flow issues exposed during single-layer validation
       - Avoid problem accumulation until final integration

# Intelligent Problem Handling
problem_classification_handling:
  minor_issues:
    examples: ["missing files", "syntax errors", "import path errors"]
    handling: "Claude auto-analyzes and fixes, continues execution"
    
  medium_issues:
    examples: ["interface mismatches", "data type conflicts", "test failures"]
    handling: "Task(senior-developer) deep analysis, attempt automatic fix"
    
  major_issues:
    examples: ["architecture design conflicts", "requirement misunderstanding", "technology stack adjustments"]
    handling: "Generate detailed report, pause for human intervention"

  handling_logic: |
    Claude intelligently handles problems during execution:
    
    - Regular checks: Use ls, find, npm test, etc. to check status
    - Auto-classification: Categorize problems by severity level
    - Smart fixes: Direct fix for minor issues, AI analysis for medium issues
    - Timely escalation: Major problems immediately reported, await human decision
    
    Goal: Only problems requiring human decision interrupt the workflow

# Practical Coordinator Execution Logic
coordinator_executable_logic:
  status_management: |
    # Create necessary directories
    mkdir -p .claude/state .claude/reports .claude/config
    
    # Check current status
    if [ -f ".claude/state/current.json" ]; then
      current_stage=$(jq -r '.stage // "start"' .claude/state/current.json)
      echo "Current stage: $current_stage"
    else
      echo '{"stage": "start", "timestamp": "'$(date)'"}' > .claude/state/current.json
    fi
  
  validation_commands: |
    # Check project structure
    echo "ðŸ“ Checking project structure..."
    find src/ -type d 2>/dev/null | head -10
    
    # Count files
    file_count=$(find src/ -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" 2>/dev/null | wc -l)
    echo "ðŸ“„ Generated files: $file_count"
    
    # Run tests
    if [ -f "package.json" ]; then
      echo "ðŸ§ª Running tests..."
      npm test 2>/dev/null || echo "âš ï¸ Tests failed, need fixing"
    fi
    
    # Check Git status
    git status --porcelain | head -5
  
  problem_detection: |
    issues=()
    
    # Check basic structure
    test -d src/ || issues+=("Missing src directory")
    test -f package.json || issues+=("Missing package.json")
    
    # Check file count
    file_count=$(find src/ -name "*.js" -o -name "*.jsx" 2>/dev/null | wc -l)
    [ $file_count -lt 2 ] && issues+=("Too few files generated")
    
    # Report issues
    if [ ${#issues[@]} -gt 0 ]; then
      echo "ðŸš¨ Issues found: ${issues[@]}"
      echo "Need AI analysis for resolution"
    else
      echo "âœ… Validation passed"
    fi

# Configuration Templates
config_templates:
  medium_project_example: |
    {
      "project_type": "medium",
      "modules": [
        {
          "name": "user-authentication",
          "priority": 1,
          "dependencies": [],
          "backend_required": true,
          "frontend_required": true,
          "description": "User login and registration functionality"
        },
        {
          "name": "core-business",
          "priority": 2,
          "dependencies": ["user-authentication"],
          "backend_required": true,
          "frontend_required": true,
          "description": "Main business functionality"
        },
        {
          "name": "admin-dashboard",
          "priority": 3,
          "dependencies": ["user-authentication", "core-business"],
          "backend_required": false,
          "frontend_required": true,
          "description": "Administrative interface"
        }
      ],
      "development_layers": {
        "layer_1": ["user-authentication"],
        "layer_2": ["core-business"],
        "layer_3": ["admin-dashboard"]
      }
    }

# Usage Instructions
usage_guide: |
  Simple Usage:
  
  User: "Help me develop a blog system with article publishing, user management, and comment functionality"
  
  Claude automatically executes:
  1. Analyze requirements, design architecture, generate module configuration
  2. Progressive development by dependency layers:
     Layer 1: User management module
     Layer 2: Article publishing module (depends on user management)
     Layer 3: Comment functionality module (depends on previous two)
  3. Validate each layer immediately after completion, catch issues early
  4. Final quality assurance and documentation generation
  
  Key Advantages:
  âœ… Avoid integration hell - Progressive integration prevents issue accumulation
  âœ… Reduce human supervision - Intelligent problem handling
  âœ… Wide applicability - Suitable for medium to large projects
  âœ… Actually executable - Designed based on Claude Code's real capabilities

# Relationship with Original Workflow
inherits_from_original:
  - "Retain your excellent agent definitions"
  - "Retain enterprise-level quality control concepts"
  - "Retain multi-agent collaboration mechanisms"
  
improvements:
  - "Simplified to unified process, avoiding complexity selection"
  - "Strengthened progressive integration mechanism"
  - "Optimized for natural language execution"
  - "Enhanced intelligent problem handling capabilities"

# Quick Start Example
quick_start: |
  User input: "I want to build an e-commerce system with product catalog, shopping cart, user accounts, and payment processing"
  
  Claude execution:
  1. Analysis: 4 modules identified with clear dependencies
  2. Layer planning:
     - Layer 1: user-accounts (no dependencies)
     - Layer 2: product-catalog (minimal user dependency)
     - Layer 3: shopping-cart (depends on users + products)
     - Layer 4: payment-processing (depends on all previous)
  3. Progressive development with validation at each layer
  4. Early integration issue detection and resolution
  5. Comprehensive testing and deployment preparation
  
  Expected result: Fully integrated system without integration hell issues