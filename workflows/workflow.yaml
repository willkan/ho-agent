version: "3.0"
name: "Progressive Integration Development Workflow"
description: "Unified workflow focusing on solving integration hell through progressive integration"

# Core Philosophy
design_principles:
  - "Progressive integration - solve integration hell at its root"
  - "Natural language execution - Claude intelligently understands and executes"
  - "Intelligent problem handling - minimize human supervision"
  - "Layer-by-layer validation - catch issues early"
  - "Continuous automation - stages flow automatically without human confirmation"
  - "Smart validation recovery - always return to complete solution after simple tests"

# Applicability
applicable_projects:
  - "Projects with 2+ modules requiring integration"
  - "Medium to large development projects"
  - "Any project where module interdependency exists"

non_applicable_projects:
  - "Single-file or single-module simple tools"
  - "Pure static pages"
  - "Simple scripts"

# Unified Workflow Execution Logic
workflow_execution: |
  IMPORTANT: This workflow is executed by Claude Code in the target project, not in this framework repository.
  When a user copies this workflow to their project and asks Claude Code to use it, follow these instructions:
  
  Claude, this project has multiple modules and needs progressive integration to avoid integration hell:

  Stage 1 - Complete Planning and Design:
  Execute concurrently:
  - Task(requirements-analyst, "Analyze user requirements thoroughly, output requirements document")
  - Task(technical-architect, "Design system architecture with focus on module separation and interface design")
  - Task(ux-designer, "Design user interface and interaction flows")
  
  After planning completion:
  - Task(project-manager, "Based on architecture design, generate module configuration file including:
    * All modules list with priorities and dependencies
    * Layered development plan based on dependency relationships  
    * Detailed interface definitions and data models")
  
  Stage 2 - Progressive Development (CORE! Solves integration hell):
  
  Read module configuration file, execute by dependency layers:
  
  2.1) Develop Layer 1 modules (foundation modules with no dependencies):
       For each Layer 1 module, execute concurrently:
       - If backend_required: Task(backend-developer, "Develop ${module_name} backend, strictly follow interface definitions")
       - If frontend_required: Task(frontend-developer, "Develop ${module_name} frontend, use mock data for testing")
  
  2.2) Layer 1 Validation (CRITICAL STEP!):
       - Check if module files are completely generated
       - Verify API interfaces are implemented according to definitions
       - Run unit tests
       - Attempt to start services and test basic functionality
       
       ❌ If validation fails:
       - STOP immediately, do NOT proceed to Layer 2
       - Task(code-reviewer, "Analyze Layer 1 integration issues, provide specific fix solutions")
       - After fixes, re-validate Layer 1
       - IMPORTANT: After fixing, automatically re-run validation
       
       ✅ If validation passes:
       - Mark Layer 1 as COMPLETED in state
       - AUTOMATICALLY proceed to Layer 2 development
       - NO HUMAN CONFIRMATION NEEDED - continue immediately
  
  2.3) Develop Layer 2 modules (dependent on Layer 1):
       - Develop based on validated Layer 1 interfaces
       - Task calls explicitly state: "Based on completed ${dependency_modules} interfaces, develop ${current_module}"
  
  2.4) Layer 2 Validation:
       - Run cross-module integration tests
       - Verify data flow between Layer 1 and Layer 2
       - Test complete business processes
       
       ✅ If validation passes:
       - AUTOMATICALLY continue to next layer
       - NO PAUSE for human confirmation
       - Update progress state and continue
  
  Continue this pattern - each layer MUST pass validation before AUTOMATICALLY proceeding to next layer.
  
  AUTOMATION RULE: After ANY validation success, immediately continue to next stage WITHOUT asking "Should I continue?" or "Would you like me to proceed?"
  
  Stage 3 - Quality Assurance:
  - Task(qa-engineer, "Comprehensive testing of all features, focus on inter-module integration")
  - When issues found: Task(code-reviewer, "Analyze problems and provide fix recommendations")
  - Generate test reports and deployment documentation
  
  KEY PRINCIPLE: Validate each layer immediately after completion, catch and fix issues early, 
  avoid problem accumulation until final integration!

# Progressive Integration Core Mechanism
progressive_integration_solution:
  problem_root_cause: "Traditional development has modules developed independently, causing massive interface mismatch issues during final integration"
  
  solution_approach: |
    1. Dependency Analysis:
       - Automatically analyze inter-module dependency relationships
       - Organize modules into different layers based on dependencies
       - Layer 1: Foundation modules with no dependencies
       - Layer 2: Modules dependent only on Layer 1
       - Layer 3: Modules dependent on previous layers
    
    2. Layer-by-Layer Development:
       - Same-layer modules can be developed concurrently (no dependency conflicts)
       - Different layers must be developed sequentially
       - Subsequent layers must wait for previous layer validation
    
    3. Layer Validation:
       After each layer completion, immediately validate:
       - Are API interfaces implemented according to definitions?
       - Are data models consistent?
       - Are module calls functioning properly?
       - Do integration tests pass?
       
       Validation failure = immediate stop for fixes
       Validation success = proceed to next layer
    
    4. Early Problem Detection:
       - Interface mismatches discovered during development phase
       - Data flow issues exposed during single-layer validation
       - Avoid problem accumulation until final integration

# Intelligent Problem Handling
problem_classification_handling:
  minor_issues:
    examples: ["missing files", "syntax errors", "import path errors"]
    handling: "Claude auto-analyzes and fixes, continues execution WITHOUT PAUSE"
    
  medium_issues:
    examples: ["interface mismatches", "data type conflicts", "test failures"]
    handling: |
      1. Task(senior-developer) deep analysis, attempt automatic fix
      2. If temporary validation needed (simple-xx, test-xx, minimal-xx, quick-xx, demo-xx, poc-xx, etc.): 
         - Create temporary/simplified test case
         - Validate hypothesis
         - CRITICAL: After ANY temporary validation, MUST return to FULL implementation
         - Track state: {original_task: "full_implementation", temp_validation: "type_of_test", validation_status: "completed"}
         - Recognize patterns: simple-*, test-*, minimal-*, quick-*, demo-*, poc-*, temp-*, basic-*
      3. Continue execution automatically after fix
    
  major_issues:
    examples: ["architecture design conflicts", "requirement misunderstanding", "technology stack adjustments"]
    handling: "Generate detailed report, pause for human intervention"

  handling_logic: |
    Claude intelligently handles problems during execution:
    
    VALIDATION FILE PROTOCOL:
    1. Temporary validation files are ALLOWED for debugging
    2. But MUST follow complete lifecycle:
       - CREATE temp file and track it
       - VALIDATE hypothesis
       - APPLY solution to original file
       - DELETE temp file
       - VERIFY original problem is fixed
    3. FORBIDDEN: Stopping at validation success
       - simple-server.js works ≠ task complete
       - Must fix server.js and delete simple-server.js
       - Track all temp files to ensure cleanup
    
    AUTOMATION RULES:
    1. NEVER ask "Should I continue?" after successful validation
    2. ALWAYS auto-proceed to next stage when current stage completes
    3. Direct problem solving - no temporary escapes, no simplified versions
    4. Remember: "The only way out is through" - fix problems where they are
    
    Goal: Direct problem resolution with minimal human intervention

# Coordinator Execution Instructions
coordinator_instructions:
  status_management: |
    Claude, when coordinating the workflow:
    
    1. Initialize project structure:
       - Create necessary directories for state tracking if needed
       - Set up initial stage as "start"
    
    2. Track current progress:
       - Maintain awareness of current stage in your context
       - Record completion of each stage
       - Automatically determine and proceed to next stage without asking user
  
  validation_approach: |
    Claude, validate each stage by:
    
    1. Structure validation:
       - Use LS tool to check if expected directories exist
       - Use Glob tool to verify files are generated
       - Ensure module organization matches architecture
    
    2. Code validation:
       - Count generated files to ensure completeness
       - Verify all required components are present
    
    3. Test validation:
       - Use Bash tool to run tests if available
       - If tests fail, analyze errors and fix automatically
       - Continue workflow after fixing - do not pause to ask user
    
    4. Automatic progression:
       - When validation passes, immediately proceed to next stage
       - Do not ask "Should I continue?" or similar questions
  
  problem_detection_strategy: |
    Claude, detect and handle problems automatically:
    
    1. Check for common issues:
       - Use LS and Glob tools to verify expected structure
       - Check if core files like package.json exist
       - Ensure sufficient code has been generated
    
    2. Issue resolution by severity:
       - Minor issues: Fix immediately and continue without pause
       - Medium issues: May create temporary test to validate fix, but MUST return to full implementation
       - Major issues: Only these require human intervention
    
    3. Validation success behavior:
       - When validation passes, state "Validation passed, proceeding to next stage"
       - Immediately continue without asking for permission
       - Track that this stage is complete and move forward

# Configuration Templates
config_templates:
  medium_project_example: |
    {
      "project_type": "medium",
      "modules": [
        {
          "name": "user-authentication",
          "priority": 1,
          "dependencies": [],
          "backend_required": true,
          "frontend_required": true,
          "description": "User login and registration functionality"
        },
        {
          "name": "core-business",
          "priority": 2,
          "dependencies": ["user-authentication"],
          "backend_required": true,
          "frontend_required": true,
          "description": "Main business functionality"
        },
        {
          "name": "admin-dashboard",
          "priority": 3,
          "dependencies": ["user-authentication", "core-business"],
          "backend_required": false,
          "frontend_required": true,
          "description": "Administrative interface"
        }
      ],
      "development_layers": {
        "layer_1": ["user-authentication"],
        "layer_2": ["core-business"],
        "layer_3": ["admin-dashboard"]
      }
    }

# Usage Instructions
usage_guide: |
  Simple Usage:
  
  User: "Help me develop a blog system with article publishing, user management, and comment functionality"
  
  Claude automatically executes:
  1. Analyze requirements, design architecture, generate module configuration
  2. Progressive development by dependency layers:
     Layer 1: User management module
     Layer 2: Article publishing module (depends on user management)
     Layer 3: Comment functionality module (depends on previous two)
  3. Validate each layer immediately after completion, catch issues early
  4. Final quality assurance and documentation generation
  
  Key Advantages:
  ✅ Avoid integration hell - Progressive integration prevents issue accumulation
  ✅ Reduce human supervision - Intelligent problem handling
  ✅ Wide applicability - Suitable for medium to large projects
  ✅ Actually executable - Designed based on Claude Code's real capabilities

# Relationship with Original Workflow
inherits_from_original:
  - "Retain your excellent agent definitions"
  - "Retain enterprise-level quality control concepts"
  - "Retain multi-agent collaboration mechanisms"
  
improvements:
  - "Simplified to unified process, avoiding complexity selection"
  - "Strengthened progressive integration mechanism"
  - "Optimized for natural language execution"
  - "Enhanced intelligent problem handling capabilities"

# Quick Start Example
quick_start: |
  User input: "I want to build an e-commerce system with product catalog, shopping cart, user accounts, and payment processing"
  
  Claude execution:
  1. Analysis: 4 modules identified with clear dependencies
  2. Layer planning:
     - Layer 1: user-accounts (no dependencies)
     - Layer 2: product-catalog (minimal user dependency)
     - Layer 3: shopping-cart (depends on users + products)
     - Layer 4: payment-processing (depends on all previous)
  3. Progressive development with validation at each layer
  4. Early integration issue detection and resolution
  5. Comprehensive testing and deployment preparation
  
  Expected result: Fully integrated system without integration hell issues

# Automation Execution Guidelines
automation_guidelines:
  continuous_flow:
    description: "Ensure continuous workflow without unnecessary pauses"
    rules:
      - "After any stage validation passes, IMMEDIATELY continue to next stage"
      - "Do NOT ask 'Should I continue?' or 'Would you like me to proceed?'"
      - "Only pause for: architecture approval, deployment approval, major failures"
      - "Minor and medium issues should be fixed and execution continued automatically"
  
  validation_recovery:
    description: "Proper handling of temporary validation tests (ANY pattern)"
    process: |
      When encountering issues requiring validation:
      1. Create temporary test case for hypothesis validation
         Common patterns: simple-*, test-*, minimal-*, quick-*, demo-*, poc-*, temp-*, basic-*
      2. Run the temporary test to verify assumptions
      3. CRITICAL: After validation, MUST return to full implementation
      4. Track state to ensure return to original task:
         {
           "original_task": "full_user_management_system",
           "validation_test": "minimal-auth-test",  // could be any pattern
           "is_temporary": true,
           "validation_result": "passed",
           "next_action": "implement_full_solution"
         }
      5. Never consider ANY temporary/simplified test as the final solution
      6. Always complete the original full implementation
      
      Pattern detection regex: /^(simple|test|minimal|quick|demo|poc|temp|basic)[-_]/
    
    common_mistakes_to_avoid:
      - "Forgetting to return to full implementation after temporary test"
      - "Treating ANY temporary validation (simple-xx, test-xx, minimal-xx, etc.) as task completion"
      - "Losing track of original requirements during validation"
      - "Not recognizing temporary test patterns beyond simple-xx"
      - "Stopping at poc/demo/test implementation instead of full solution"
  
  human_intervention_minimization:
    mandatory_only:
      - "Project requirements approval (initial only)"
      - "Major architecture changes (breaking changes)"
      - "Production deployment approval"
    
    auto_handled:
      - "Stage transitions after validation"
      - "Minor bug fixes and adjustments"
      - "Module integration after successful tests"
      - "Documentation updates"
      - "Test execution and re-runs"
    
    decision_tree: |
      Is validation successful?
        YES -> Continue to next stage automatically
        NO -> Is it a minor issue?
          YES -> Fix and continue automatically
          NO -> Is it a medium issue?
            YES -> Analyze, fix, validate, continue automatically
            NO -> Is it a major architectural issue?
              YES -> Stop and request human intervention
              NO -> Attempt intelligent resolution and continue

# State Tracking for Automation
state_tracking:
  required_state_files:
    - ".claude/state/current_stage.json"
    - ".claude/state/validation_history.json"
    - ".claude/state/original_tasks.json"
  
  state_tracking_guidelines: |
    Claude, maintain state awareness throughout execution:
    
    1. After completing each stage:
       - Remember what stage was just completed
       - Identify the next stage to execute
       - Proceed to next stage automatically
    
    2. When creating temporary validations:
       - Recognize patterns: simple-*, test-*, minimal-*, quick-*, demo-*, poc-*, temp-*, basic-*
       - Remember this is temporary and track the original full task
       - After validation succeeds, ALWAYS return to implement the full solution
    
    3. Before considering any task complete:
       - Verify you've implemented the full original requirements
       - Ensure you're not stopping at a temporary validation
       - Check that all originally requested features are present